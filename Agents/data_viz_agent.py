import openai
import config
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
from semantic_kernel.functions import kernel_function
from openai import OpenAI
import streamlit as st
from io import BytesIO
import json
import logging
import re
import tempfile
import os
import uuid

# Set default Plotly template for better visuals
pio.templates.default = "plotly_white"
# Configure Plotly to open in browser when show() is called
pio.renderers.default = "json"  # Changed from "json" to "browser"

logger = logging.getLogger(__name__)

class DataVizAgent:
    def __init__(self, data_extractor_agent, memory=None):
        """
        Initialize the DataVizAgent with an instance of DataExtractorAgent
        to execute the SQL queries.
        """
        self.data_extractor_agent = data_extractor_agent
        self.memory = memory

    @kernel_function
    async def execute_sql_query(self, sql_query):
        """
        Execute the provided SQL query and return a DataFrame.
        This function will execute the SQL query generated by the SQL Generator Agent.
        """
        # Connect to the DataExtractorAgent to execute the query
        result_df = self.data_extractor_agent.execute_query(sql_query)
        print(type(result_df))
        # Ensure that the result is a DataFrame and handle any possible dict/list format
        if isinstance(result_df, pd.DataFrame):
            print("Query executed successfully and result is a DataFrame.")
            return result_df
        elif isinstance(result_df, dict) or isinstance(result_df, list):
            print("Converting result to DataFrame from dict/list format.")
            return pd.DataFrame(result_df)
        else:
            raise Exception("Failed to retrieve valid data from the database. Unexpected format.")

    def is_categorical(self, df, column):
        """Determine if a column should be treated as categorical."""
        if df[column].dtype == 'object' or df[column].dtype.name == 'category':
            return True
        if df[column].dtype in ['int64', 'float64'] and df[column].nunique() < 10:
            return True
        return False

    def format_axis_title(self, column_name):
        """Format column name into a proper axis title."""
        # Replace underscores and capitalize words
        formatted = column_name.replace('_', ' ').title()
        # Handle common abbreviations
        replacements = {
            'Id': 'ID', 
            'Qty': 'Quantity',
            'Num': 'Number',
            'Amt': 'Amount'
        }
        for abbr, full in replacements.items():
            formatted = formatted.replace(abbr, full)
        return formatted

    def get_plot_title(self, question, df):
        """Generate an appropriate plot title based on question and data."""
        # Extract key terms from question
        question = question.strip('?').lower()
        
        # Start with default pattern
        if question.startswith('show me'):
            question = question[8:]
            
        if 'by' in question:
            parts = question.split('by')
            metric = parts[0].strip()
            dimension = parts[1].strip()
            return f"{metric.title()} by {dimension.title()}"
        
        # If not a standard pattern, create title from main data columns
        if len(df.columns) >= 2:
            y_col = self.format_axis_title(df.columns[1])
            x_col = self.format_axis_title(df.columns[0])
            return f"{y_col} by {x_col}"
        
        # Fallback title
        return f"Analysis of {self.format_axis_title(df.columns[0])}"

    def format_specific_chart_type(self, fig, df, monetary_columns):
        """Apply chart-specific formatting based on the figure type."""
        if not fig.data:
            return
            
        chart_type = fig.data[0].type
        
        if chart_type == 'bar':
            # Format bar charts
            for trace in fig.data:
                y_col = trace.name or df.columns[1] if len(df.columns) > 1 else None
                if y_col in monetary_columns:
                    trace.texttemplate = '$%{y:,.0f}'
                else:
                    trace.texttemplate = '%{y:,.0f}'
                trace.textposition = 'outside'
            
            # Ensure x-axis labels are properly displayed
            x_values = df[df.columns[0]].astype(str)
            fig.update_xaxes(
                tickmode='array',
                tickvals=list(range(len(x_values))),
                ticktext=x_values,
                tickangle=-45 if len(max(x_values, key=len)) > 10 else 0,
                showticklabels=True
            )
                
        elif chart_type == 'pie':
            # Format pie charts
            for trace in fig.data:
                trace.textinfo = 'label+percent'
                trace.textposition = 'inside'
                
        elif chart_type in ['scatter', 'line']:
            # Format scatter plots and line charts
            for trace in fig.data:
                y_col = trace.name or df.columns[1] if len(df.columns) > 1 else None
                if y_col in monetary_columns:
                    trace.hovertemplate = '%{x}<br>$%{y:,.2f}<extra></extra>'
                else:
                    trace.hovertemplate = '%{x}<br>%{y:,.0f}<extra></extra>'
                
                # Add markers for better visibility on line charts
                if chart_type == 'line' and len(df) < 20:
                    trace.mode = 'lines+markers'
                    
                # Add marker labels for scatter plots
                if chart_type == 'scatter':
                    trace.mode = 'markers+text'
                    trace.textposition = 'top center'
                    trace.texttemplate = '%{x}'

    @kernel_function
    async def determine_plot_type(self, df, query, viz_type=None):
        """
        Determine and generate the appropriate plot based on the data and query.
        
        Args:
            df: DataFrame to visualize
            query: User query
            viz_type: Optional parameter for future use
        """
        # Initialize client
        client = OpenAI(api_key=config.OPENAI_API_KEY)

        # 1. Fix the monetary column detection logic
        monetary_columns = []
        time_indicators = ['month', 'year', 'date', 'time', 'day', 'quarter', 'week']

        for col in df.columns:
            col_lower = col.lower()
            
            # First check if it's a time-related column - these should NEVER get $ formatting
            is_time_column = False
            for time_word in time_indicators:
                if time_word in col_lower:
                    is_time_column = True
                    break
            
            if is_time_column:
                # Skip monetary formatting for any time-related columns
                continue
                
            # Only then check if it's truly a monetary column
            if (col_lower.endswith(('price', 'cost', 'revenue', 'sales', 'total', 'amount')) or
                'price' in col_lower or 'cost' in col_lower or 'revenue' in col_lower or
                'amount' in col_lower):
                monetary_columns.append(col)

        print(f"Monetary columns that will receive $ formatting: {monetary_columns}")

        # Check if this is a visualization-only request
        # and if we should use memory instead of the provided df
        if self.memory and self.memory.has_data:
            # Check logic to determine if we should use memory
            # For now, always use the provided df
            pass
        
        # Convert dict to string for prompt if df is a dict
        if isinstance(df, dict):
            df_string = "\n".join([f"{k}: {v}" for k, v in df.items()])
        else:
            # Limit the dataframe preview to avoid huge prompts
            df_string = df.to_string()
            df_shape = df.shape
            
            # Get column data types for formatting guidance
            data_types = df.dtypes.to_dict()
            data_types_str = "\n".join([f"{col}: {dtype}" for col, dtype in data_types.items()])

        # 2. Add explicit instructions to prevent SQL in plots
        visualization_instructions = """
        # Visualization Creation Guidelines
        Follow these detailed instructions to create well-formatted, professional visualizations:
        
        ## Chart Selection
        - Bar charts: Use for comparing categorical data or time periods
        - Line charts: Use for trends over time or continuous relationships
        - Scatter plots: Use for correlation analysis between two variables
        - Pie charts: Use only for part-to-whole relationships with few categories (<7)
        - Box plots: Use for distribution and outlier analysis
        - Heatmaps: Use for correlation matrices or complex relationships
        
        ## Essential Formatting Requirements
        1. Titles and Labels:
           - Create a clear, descriptive title that answers the user's question
           - Label both axes with full descriptive names (not column codes)
           - Include units of measurement in axis labels when applicable
        
        2. Data Formatting:
           - Apply currency formatting ($) ONLY to monetary values (columns with names containing price, cost, revenue, sales, total, amount)
           - Use thousands separators for all numeric values
           - Format percentages with % symbol and appropriate decimal places
           - Format dates consistently in a human-readable format
 
        3. Colors and Legends:
           - Use colorblind-friendly palettes (avoid red-green combinations)
           - Include legends for multiple data series, positioned to avoid overlap
           - Use consistent color mapping for the same categories
           - Apply proper contrast for readability
        
        4. Data Presentation:
           - Sort data meaningfully (ascending, descending, or chronological)
           - Limit the number of categories shown (use "Other" for small categories)
           - Use appropriate scale (linear vs. logarithmic) based on data range
           - Include grid lines for easier value reading if appropriate
           - Ensure ALL data points are properly labeled on axes
        
        5. Technical Specifications:
           - Set appropriate figure size based on data complexity
           - Use consistent font family and sizes throughout
           - Ensure sufficient white space to avoid crowding
           - Apply the 'plotly_white' template as base styling

        If you include fig.show(), make sure to configure it properly to open in a new browser window:
        fig.show(renderer='browser')

        IMPORTANT: 
        - Do NOT include any SQL code, SQL keywords, or query text in plot titles, labels, or annotations
        - Use clear, descriptive business titles that explain the data being shown
        - NEVER format time periods, dates, or sequence numbers (like months, years, IDs) with currency symbols
        """

        prompt = f"""
        The SQL query '{query}' has been executed, and the following DataFrame (showing all {df_shape[0] if 'df_shape' in locals() else '?'} rows) has been generated:
        {df_string}
        
        Column data types:
        {data_types_str if 'data_types_str' in locals() else 'Not available'}

        I will provide data preprocessing information below to help you understand the DataFrame structure:
        DataFrame column types for visualization (USING RAW DATA):
        {", ".join([f"{col}: {df[col].dtype}, Sample: {df[col].iloc[0]}" for col in df.columns])}

        Monetary columns (these should use $ formatting): {', '.join(monetary_columns)}

        IMPORTANT: You must use the ACTUAL DataFrame provided to you directly. DO NOT create sample data or recreate the DataFrame.

        {visualization_instructions}

        IMPORTANT: Do NOT include fig.show() in your code as it will cause errors. Just define and return the figure.

        Based on this query and data, please:
        
        1. Create a visualization using the provided DataFrame ('df')
        2. Format numeric values appropriately ($ for money, % for percentages)
        3. Use the 'plotly_white' template for a clean look
        4. Keep the code simple and straightforward
        5. ALWAYS use the variable 'df' in your code as it contains the actual query results
        6. DO NOT create new sample data or a new DataFrame
        7. ENSURE all data points are clearly labeled on the x-axis
        8. Use concise, clear business titles - NO SQL or technical code in titles or labels
        
        Your response should have two parts:
        
        PART 1: Python code using Plotly Express that creates the visualization directly from the provided DataFrame
        PART 2: A brief explanation (2-3 sentences) explaining why this visualization was chosen
        
        Separate the parts with "---EXPLANATION---" on its own line.
        """
        
        # Print preprocessing info for debugging
        print("Column types after preprocessing:")
        for col in df.columns:
            print(f"{col}: {df[col].dtype}")
        
        # Create separate DataFrames for display vs. visualization to avoid modification issues
        print("Using separate DataFrames for display and visualization")
        viz_df = df.copy()
        print("Using provided DataFrame for visualization")
        print("DataFrame column types for visualization (USING RAW DATA):")
        for col in df.columns:
            print(f"{col}: {df[col].dtype}, Sample: {df[col].iloc[0]}")
        
        try:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            full_response = response.choices[0].message.content
            
            # Split code and explanation
            if full_response and "---EXPLANATION---" in full_response:
                parts = full_response.split("---EXPLANATION---")
                plot_code = parts[0].strip()
                explanation = parts[1].strip()
            else:
                # Default handling if separator not found
                plot_code = full_response
                explanation = "This visualization was chosen to best represent the data from your query."
            
            # Extract the clean code
            clean_code = plot_code.strip()
            if "```python" in clean_code:
                clean_code = clean_code.split("```python")[1].split("```")[0].strip()
            elif "```" in clean_code:
                clean_code = clean_code.split("```")[1].split("```")[0].strip()
            
            # Modify the clean_code to use browser renderer if it contains fig.show()
            if 'fig.show()' in clean_code:
                print("Removing fig.show() to prevent opening in browser window")
                clean_code = clean_code.replace('fig.show()', '')
            elif 'fig.show(' in clean_code:
                # Remove any fig.show with parameters
                print("Removing fig.show() with parameters")
                clean_code = re.sub(r'fig\.show\([^)]*\)', '', clean_code)
            
            print(f"Generated Plotly code:\n{clean_code}")
            print(f"Explanation:\n{explanation}")
            
            # Create a namespace for execution
            exec_globals = {"df": df, "px": px, "pd": pd, "go": go}
            
            # Display data to be visualized
            print("Data to be visualized (first 5 rows, RAW FROM DATABASE):")
            print(df.head().to_string())
            
            # Add this code right after line 257, before executing the Plotly code
            # Improved monetary column detection - specifically check for time-related columns
            monetary_columns = []
            time_indicators = ['month', 'year', 'date', 'time', 'day', 'quarter', 'week']

            for col in df.columns:
                col_lower = col.lower()
                
                # First check if it's a time-related column - these should NEVER get $ formatting
                is_time_column = False
                for time_word in time_indicators:
                    if time_word in col_lower:
                        is_time_column = True
                        break
                
                if is_time_column:
                    # Skip monetary formatting for any time-related columns
                    continue
                    
                # Only then check if it's truly a monetary column
                if (col_lower.endswith(('price', 'cost', 'revenue', 'sales', 'total', 'amount')) or
                    'price' in col_lower or 'cost' in col_lower or 'revenue' in col_lower or
                    'amount' in col_lower):
                    monetary_columns.append(col)

            print(f"Monetary columns that will receive $ formatting: {monetary_columns}")
            
            # Execute the code
            exec(clean_code, exec_globals)
            
            # Find the Plotly figure in the execution namespace
            fig = None
            for var_name, var_value in exec_globals.items():
                if var_name != "df" and var_name != "px" and var_name != "pd" and var_name != "go" and not var_name.startswith("__"):
                    if hasattr(var_value, 'to_html'):
                        fig = var_value
                        break
            
            if fig is None:
                # If no explicit figure found, look for the last assigned variable
                for var_name in reversed(list(exec_globals.keys())):
                    if var_name != "df" and var_name != "px" and var_name != "pd" and var_name != "go" and not var_name.startswith("__"):
                        if hasattr(exec_globals[var_name], 'to_html'):
                            fig = exec_globals[var_name]
                            break
            
            if fig is None:
                print("Error: No figure found. This might be due to the fig.show() issue.")
                # Try to search for 'fig =' in the code and extract just that part
                if 'fig =' in clean_code:
                    fig_code = '\n'.join([line for line in clean_code.split('\n') if not 'show()' in line])
                    print(f"Attempting to execute code without fig.show(): {fig_code}")
                    exec(fig_code, exec_globals)
                    # Try to find the figure again
                    for var_name, var_value in exec_globals.items():
                        if var_name != "df" and var_name != "px" and var_name != "pd" and var_name != "go" and not var_name.startswith("__"):
                            if hasattr(var_value, 'to_html'):
                                fig = var_value
                                break
            
            if fig is None:
                print("No Plotly figure found in the generated code")
                return None, None
            
            # Apply improved formatting to the figure
            if fig:
                # Apply consistent base template
                fig.update_layout(
                    template='plotly_white',
                    # Improve title formatting
                    title={
                        'text': self.get_plot_title(query, df),
                        'y': 0.95,
                        'x': 0.5,
                        'xanchor': 'center',
                        'yanchor': 'top',
                        'font': {'size': 16, 'color': '#1f77b4'}
                    },
                    # Ensure margins are adequate
                    margin={'l': 40, 'r': 40, 't': 60, 'b': 40},
                    # Add hover label formatting
                    hovermode='closest',
                    legend={'orientation': 'h', 'yanchor': 'bottom', 'y': -0.3} if len(df.columns) > 2 else None
                )
                
                # Format axes based on data types
                for i, col in enumerate(df.columns):
                    if i == 0:  # Usually x-axis
                        fig.update_xaxes(
                            title={'text': self.format_axis_title(col), 'font': {'size': 14}},
                            tickangle=-45 if self.is_categorical(df, col) and df[col].nunique() > 5 else 0,
                            showticklabels=True
                        )
                    elif i == 1:  # Usually y-axis
                        fig.update_yaxes(
                            title={'text': self.format_axis_title(col), 'font': {'size': 14}},
                            tickformat='$,.0f' if col in monetary_columns else ',.0f'
                        )
                
                # Apply specific chart formatting
                self.format_specific_chart_type(fig, df, monetary_columns)
                
                # Fix text display issues
                if hasattr(fig, 'data') and fig.data:
                    for trace in fig.data:
                        if hasattr(trace, 'texttemplate') and '%{text}' in str(trace.texttemplate):
                            trace.texttemplate = None
            
            # 3. Add a simple check to clean any SQL from the title after generation
            if fig is not None:
                # Get the current title
                current_title = fig.layout.title.text if hasattr(fig.layout, 'title') and hasattr(fig.layout.title, 'text') else ""
                
                # Remove common SQL keywords if they appear
                sql_keywords = ['SELECT', 'FROM', 'WHERE', 'GROUP BY', 'ORDER BY', 'JOIN']
                cleaned_title = current_title
                for keyword in sql_keywords:
                    if keyword in cleaned_title:
                        cleaned_title = cleaned_title.replace(keyword, '')
                
                # Update the title if it was changed
                if cleaned_title != current_title:
                    fig.update_layout(title_text=cleaned_title)
            
            # Return both the figure and the explanation
            return fig, explanation
        except Exception as e:
            print(f"Error executing plot code: {e}")
            # Try to extract just the figure creation part without the show() call
            if 'fig =' in clean_code and 'fig.show()' in clean_code:
                try:
                    print("Trying to execute code without fig.show()")
                    modified_code = clean_code.replace('fig.show()', '')
                    exec(modified_code, exec_globals)
                    # Look for the figure
                    for var_name, var_value in exec_globals.items():
                        if var_name != "df" and var_name != "px" and var_name != "pd" and var_name != "go" and not var_name.startswith("__"):
                            if hasattr(var_value, 'to_html'):
                                fig = var_value
                                print("Successfully created figure after removing fig.show()")
                                return fig, explanation
                except Exception as inner_e:
                    print(f"Error in second attempt: {inner_e}")
            
            return None, None

    def plotly_fig_to_json(self, fig):
        """
        Convert a Plotly figure to JSON that can be embedded in HTML
        """
        try:
            import json
            import plotly
            
            # Configure figure to not open external links
            if hasattr(fig, 'update_layout'):
                fig.update_layout(
                    modebar=dict(
                        activecolor='#1f77b4',
                        bgcolor='rgba(255,255,255,0.7)',
                        orientation='h',
                        remove=['sendDataToCloud', 'autoScale2d', 'hoverClosestCartesian']
                    )
                )
            
            # Convert figure to JSON
            fig_json = json.dumps(fig.to_dict(), cls=plotly.utils.PlotlyJSONEncoder)
            print(f"Successfully converted Plotly figure to JSON (length: {len(fig_json)})")
            return fig_json
        except Exception as e:
            print(f"Error converting Plotly figure to JSON: {e}")
            import traceback
            traceback.print_exc()
            return None

    def save_plot_to_temp_file(self, fig):
        """Save Plotly figure to a temporary HTML file"""
        # Generate unique filename
        unique_id = str(uuid.uuid4())[:8]
        temp_filename = f"plot_{unique_id}.html"
        file_path = os.path.join(os.getcwd(), 'temp_plots', temp_filename)
        
        # Save with full HTML (not just div)
        pio.write_html(
            fig, 
            file_path,
            full_html=True,  # Include all necessary JavaScript
            include_plotlyjs=True,
            include_mathjax=False,
            auto_open=False,
            config={
                'displayModeBar': True,
                'displaylogo': False,
                'responsive': True
            }
        )
        
        return temp_filename
